package zookeeperTest1.watchAndLock;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.I0Itec.zkclient.IZkChildListener;
import org.I0Itec.zkclient.ZkClient;
import org.apache.log4j.Logger;
import org.apache.zookeeper.CreateMode;

public class ZSZookeeperBythread {
	
	private static final Logger logger = Logger.getLogger(ZSZookeeperBythread.class);
	private String root;
	private ZkClient zk;
	private String lock_path;
	private String serverList;
	private int connectionTimeout;
	private int sessionTimeout;
	private boolean islocking;
	/** 删除事件++ */
	public static int deleteCount = 0;
	public static long wTime = 0L;
	public static int MaxWatchCount = 10000;
	
	//初始化时创建节点,包括根节点和临时节点
	public ZSZookeeperBythread(String serverList,int connectionTimeout,int sessionTimeout,String rootNode) throws Exception {
		this.serverList = serverList;
		this.connectionTimeout = connectionTimeout;
		this.sessionTimeout = sessionTimeout;
		this.root = rootNode;
		init();
	}
	
	//加锁的目的是为了保证后面创建节点的过程能顺序的执行
	private synchronized void init() throws Exception {
		if(zk==null) {
			zk = new ZkClient(serverList, sessionTimeout, connectionTimeout);
		}
		createNode();
		tryLock();
		lookNode();
		
	}
	
	public static void main(String[] args) throws Exception {
		System.out.println("monitor Start");
		ZSZookeeperBythread zs = new ZSZookeeperBythread(
				"172.28.6.131:2181,172.28.6.132:2181,172.28.6.133:2181",
//				"172.28.6.131:2186,172.28.6.132:2186,172.28.6.133:2186,172.28.6.134:2186,172.28.6.135:2186",
//				"172.28.6.131:2187,172.28.6.132:2187,172.28.6.133:2187,172.28.6.134:2187,172.28.6.135:2187,172.28.6.120:2187,172.28.6.121:2187",
				5000,
				5000,
				"/t/t1");
		System.out.println("monitor End");
	}

	/**
	 * 监控节点的异常情况
	 */
	private void lookNode() {
//		System.out.println("监控节点异常状态,node:"+lock_path);
		Executors.newScheduledThreadPool(1).scheduleWithFixedDelay(new Runnable() {
			public void run() {
				try {
					if(!zk.exists(lock_path)) {//节点被异常删除
						lock_path = zk.create(root + "/", null, CreateMode.EPHEMERAL_SEQUENTIAL);
//						System.out.println("looknode..重新创建新的临时节点:mynode:"+lock_path);
						List<String> list = zk.getChildren(root);
						if (list!=null && list.size()>0) {
							Collections.sort(list);
							String first = root + "/" + list.get(0);
//							System.out.println("looknode..mynode:"+lock_path+",firstnode:"+first);
							if (lock_path.equals(first)) {
								islocking=true;
							} else {
								islocking=false;
							}
//							System.out.println("looknode..设置lockingstate:"+islocking);
						} else {
//							System.out.println("looknode..节点数量异常!原节点为:"+lock_path);
							islocking=false;
						}
					}
					/** ZooKeeper Watcher 测试 */
					if (deleteCount == 0 ){
						wTime = System.currentTimeMillis();
						System.out.println("first ");
					}
					
					if(MaxWatchCount > deleteCount) {
						deleteCount ++;
						zk.delete(lock_path);
					} else if (MaxWatchCount == deleteCount ) {
						System.out.println(deleteCount+"次"  
								+ System.currentTimeMillis()+ " - "+"wTime = " 
								+ (System.currentTimeMillis() - wTime) +"毫秒");
						deleteCount++;
					}
					
				} catch (Exception e) {
					logger.error("", e);
				}
//				watchCount++;
			}
		}, 0, 1, TimeUnit.MILLISECONDS);

	}

	private void createNode() {
		boolean stat = zk.exists(root);
		if (stat == false) {
			// 创建根节点
			String path = zk.create(root, null, CreateMode.EPHEMERAL_SEQUENTIAL);
			System.out.println("创建根节点:"+path);
		}
		if("".equals(lock_path) || lock_path==null || !zk.exists(lock_path)) {
			lock_path = zk.create(root + "/lock_node", null, CreateMode.EPHEMERAL_SEQUENTIAL);
			System.out.println("创建临时节点:"+lock_path);
		}
	}
	
	/**
	 * 创建临时节点并判断是否获取到锁
	 * @return
	 */
	private boolean tryLock() {

		List<String> children = zk.getChildren(root);
		if (children.size() > 0) {
			Collections.sort(children);
			String first = root + "/" + children.get(0);
			if (lock_path.equals(first)) {
				islocking=true;
			} else {
				islocking=false;
				regListenner();
			}
			System.out.println("有节点:"+lock_path);
		} else {
			System.out.println("节点数量异常!原节点为:"+lock_path);
			islocking=false;
		}
		return islocking;
	}
	
	/**
	 * 客户端程序直接调用isLocking取锁即可
	 * @return true获取到锁,false没获取到
	 */
	public boolean isLocking() {
		return islocking;
	}
	
	/**
	 * 注册监听,接受通知
	 */
	private synchronized void regListenner() {

		zk.subscribeChildChanges(root, new IZkChildListener() {
			public void handleChildChange(String parentPath, List<String> currentChilds)
					throws Exception {
//				System.out.println("接受事件通知:"+currentChilds);
				
				if(!zk.exists(lock_path)) {//节点被异常删除
					lock_path = zk.create(root + "/", null, CreateMode.EPHEMERAL_SEQUENTIAL);
//					System.out.println("重新创建新的临时节点:mynode:"+lock_path);
				}
				
				if (currentChilds.size() > 0) {
					Collections.sort(currentChilds);
					String first = root + "/" + currentChilds.get(0);
//					System.out.println("mynode:"+lock_path+",firstnode:"+first);
					if (lock_path.equals(first)) {
						islocking=true;
					} else {
						islocking=false;
					}
//					System.out.println("设置lockingstate:"+islocking);
				} else {
					System.out.println("节点数量异常!原节点为:"+lock_path);
					islocking=false;
				}
			}
		});
	}
	
}
