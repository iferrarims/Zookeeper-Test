package zookeeperTest1.watchAndLock;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.Watcher.Event.KeeperState;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;
import org.apache.zookeeper.proto.SetWatches;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.ByteSerializer;

@SuppressWarnings("unused")
public class ZKMain {

	/**
	 * server列表, 以逗号分割
	 */
	/** 3 */
	protected static String hosts = "172.28.6.131:2181,172.28.6.132:2181,172.28.6.133:2181";
//	protected static String hosts1 = "172.28.6.131:2181";
//	protected static String hosts2 = "172.28.6.132:2181";
//	protected static String hosts3 = "172.28.6.133:2181";
	/** 5 */
//	protected static String hosts = "172.28.6.131:2186,172.28.6.132:2186,172.28.6.133:2186"
//				+ ",172.28.6.134:2186,172.28.6.135:2186";
	/** 7 */
//	protected static String hosts = "172.28.6.131:2181,172.28.6.132:2181,172.28.6.133:2181"
//			+ ",172.28.6.134:2187,172.28.6.135:2187,172.28.6.120:2187,172.28.6.121:2187";
	
	private static int watcherCount = 0;
	private static int watcherGetLock = 0;
	private static int watcherExist = 0;
	
	/**
	 * 连接的超时时间, 毫秒
	 */
	private static String root;
	private static String path;
	private final int SESSION_TIMEOUT = 5000;
//	private CountDownLatch connectedSignal = new CountDownLatch(hosts.split(",").length);
	private static CountDownLatch connectedSignal = new CountDownLatch(1);
	protected static ZooKeeper zk;
	private static String nodePath = "/Test/test1";
	// static String data = "a very long string about data to set to zookeeper";
	
	/** 节点总数 = threads runs 10W 节点 **/
	static int threads = 100; // 线程数
	static int runs = 100; // 迭代次数
	static int start = 0; // none

	static int size = 1024 * 4; // 写入数据的大小,单位：字节
	static byte[] testdata; // 测试数据
	/** 删除事件++ */
	public static int deleteCount;

	/**
	 * zookeeper main
	 * @param args
	 * @throws Exception
	 */
	public static void main(String[] args) throws Exception {
		//TODO
		System.out.println("set watcherCount: " + watcherCount);
		ZKMain test = new ZKMain();
//		test.connect();
		/** 测试创建根目录 */
//		test.create("/Test", "zookeeper test".getBytes());
//		test.create("/Test/test1", "Test/test1".getBytes());
		
		// 更换ZK节点数
//		test.deleteNode();
//		test.createNode();
		
//		/** 创建节点 */
//		long cTime = System.currentTimeMillis();
//		System.out.println("create watcherCount: " + watcherCount);
//		test.createNode();
//		System.out.println((System.currentTimeMillis() - cTime)/100 +"秒");
		
//		/** 设置节点数据 */
//		long sTime = System.currentTimeMillis();
//		test.setNode();
//		System.out.println((System.currentTimeMillis() - sTime)/100 +"秒");
		
//		/** 读取节点数据 */
//		long gTime = System.currentTimeMillis();
//		test.getNode();
//		System.out.println((System.currentTimeMillis() - gTime)/100 +"秒");
		
//		/** 删除节点 */
//		long dTime = System.currentTimeMillis();
//		test.deleteNode();
//		System.out.println((System.currentTimeMillis() - dTime)/100 +"秒");
		
		/** ZooKeeper Watcher 测试 */
		long wTime = System.currentTimeMillis();
//		test.testWatcher();
//		System.out.println(" watcherCount: " + watcherCount);
//		test.zkLock();
		System.out.println((System.currentTimeMillis() - wTime)/100 +"秒 10分之一");
//		System.out.println("watcher 总次数 = " + watcherCount);
		// 5.6 秒触发1000次 watcher 全部成功到达。
	}
	

	private void zkLock() throws IOException {
		/**
		 *  测试 ZooKeeper 锁。   
		 *  启动 5 10 20 个客户端对同一节点创建路径：   /Test/test1/lock_node
		 *  失败成功后 继续，失败循环-1 继续。  每个节点创建 1  3  5 次
		 *  侦测时间。
		 */
		List<ZooKeeper> list = new ArrayList<ZooKeeper>();
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		list.add(new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher()));
		
			for (int ij = 0; ij < 5; ij++) {
				try {
					testLock(list.get(ij),null,null,ij);
				} catch (KeeperException e) {
					System.out.println( "error1 " );
					e.printStackTrace();
				} catch (InterruptedException e) {
					System.out.println( "error2 " );
					e.printStackTrace();
				}
			}
	}

		/**
		 * 创建持久化节点
		 * @throws InterruptedException 
		 * @throws KeeperException 
		 */
		private static synchronized void testLock(ZooKeeper z1, String Path, byte[] data, int i) throws KeeperException, InterruptedException  {
			Path = nodePath + "/" + "lock_node";
			data = "lock_node".getBytes();
			System.out.println("now :" + i);
			z1.create(Path, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
			System.out.println("i得到锁 "+ i);
			z1.close();
			// System.out.println("创建节点:"+Path);
			// System.out.println("=================");
		}

	private void testWatcher() throws Exception {
		
		byte[] watcherDate = new byte[10];
		for (int i = 0; i < watcherDate.length; i++) {
			watcherDate [i] =  'o';
		}
//		System.out.println(nodePath+"/1_");
		String errorPath = "";
		try {
//				for (int j = 0; j < 100; j++) {
//					errorPath = nodePath+"/"+"1_"+j;
//					ZooKeeper z = new ZooKeeper(hosts, SESSION_TIMEOUT, new ConnWatcher());
//					//			ZooKeeper z11 = new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher());
//					watcherDate = (j+j+"").getBytes();
//					//			ZooKeeper z111 = new ZooKeeper(hosts, SESSION_TIMEOUT, new DeleteWatcher());
//					//				System.out.println(nodePath+"/"+"1_"+j);
//					//			System.out.println(nodePath+"/"+"1_"+j+""+j);
//					//			System.out.println(nodePath+"/"+"1_"+j+""+j+""+j);
//					z.setData((nodePath+"/"+"1_"+j), watcherDate, -1);
//					//			z11.setData((nodePath+"/"+"1_"+j+""+j), watcherDate, -1);
//					//			z11.setData((nodePath+"/"+"1_"+j+""+j+""+j), watcherDate, -1);
//				}
				for (int j = 0; j < 400; j++) {
					errorPath = nodePath+"/"+"1_"+j;
					ZooKeeper z = new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher());
					//			ZooKeeper z11 = new ZooKeeper(hosts, SESSION_TIMEOUT, new GetWatcher());
					watcherDate = (j+j+"").getBytes();
					//			ZooKeeper z111 = new ZooKeeper(hosts, SESSION_TIMEOUT, new DeleteWatcher());
					//				System.out.println(nodePath+"/"+"1_"+j);
					//			System.out.println(nodePath+"/"+"1_"+j+""+j);
					//			System.out.println(nodePath+"/"+"1_"+j+""+j+""+j);
					z.setData((nodePath+"/"+"1_"+j), watcherDate, -1);
					//			z11.setData((nodePath+"/"+"1_"+j+""+j), watcherDate, -1);
					//			z11.setData((nodePath+"/"+"1_"+j+""+j+""+j), watcherDate, -1);
				}
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println(errorPath);
		}
	}

	private void getNode() throws Exception{
		for (int m = 100; m <= 100; m += 20){
			for (int n = 1000; n <= 1000; n += 100) {
				threads = m;
				runs = n;

				GetThread[] threadArray = null;
				long begin = 0;

				threadArray = new GetThread[threads];

				WorkerStat mainStat = new WorkerStat();
				mainStat.runs = runs * threads;
				// CountDownLatch countDownLatch= new CountDownLatch(1);
				begin = System.currentTimeMillis();
				for (int i = 0; i < threads; i++) {
					threadArray[i] = new GetThread(new WorkerStat(), i);
					threadArray[i].start();
				}
				for (int i = 0; i < threads; i++) {
					threadArray[i].join();
				}
				long totalRuntime = System.currentTimeMillis() - begin;

				WorkerStat totalStat = new WorkerStat();

				totalStat.runs = runs;
				totalStat.threads = threads;
				for (int i = 0; i < threads; i++) {
					totalStat.setterTime = totalStat.setterTime
							+ threadArray[i].getStat().setterTime;
					totalStat.getterTime = totalStat.getterTime
							+ threadArray[i].getStat().getterTime;
				}
				JSONObject result = (JSONObject) JSON.toJSON(totalStat);
				result.put("totalRunTime", totalRuntime);
				result.put("totalRuns", runs * threads);
				result.put("tps", runs * threads * 1.0 / totalRuntime);
				result.put("time", new Date().toString());
				System.out.println(result);
			}
		}
	}

	private void setNode() throws Exception{
		//生成写入的数据，大小size字节
	    testdata = new byte[size];
	    for(int i=0;i<size;i++){
	        testdata[i] = 'c';
	    }
	    for(int m=100;m<=100;m+=10)
	    	for(int n=1000;n<=1000;n+=10)
	    {
	    	threads=m;
	    	runs=n;
	    SetThread[] threadArray = null;
		long begin = 0;
		
			threadArray = new SetThread[threads];
	 
			WorkerStat mainStat = new WorkerStat(); 
			mainStat.runs = runs * threads;
//			  CountDownLatch countDownLatch= new CountDownLatch(1); 
			begin = System.currentTimeMillis();
			for (int i = 0; i < threads; i++) {
			    threadArray[i] = new SetThread(new WorkerStat(),i);
			    threadArray[i].start();
			}
			for (int i = 0; i < threads; i++) {
			    threadArray[i].join();
			}
			long totalRuntime  = System.currentTimeMillis() - begin;
			  
		    WorkerStat totalStat = new WorkerStat();
		  
		    totalStat.runs=runs;
		    totalStat.threads=threads;
		    for (int i = 0; i < threads; i++) {
		        totalStat.setterTime = totalStat.setterTime + threadArray[i].getStat().setterTime;
		        totalStat.getterTime = totalStat.getterTime + threadArray[i].getStat().getterTime;
		    }
		    JSONObject result=(JSONObject) JSON.toJSON(totalStat) ;  
		    result.put("totalRunTime", totalRuntime);
		    result.put("totalRuns", runs*threads);
		    result.put("tps", runs*threads*1.0/totalRuntime);
		    result.put("time", new Date().toString());
		    System.out.println(result);  
	    }
		
	}

	private void deleteNode() throws Exception {
		// 生成写入的数据，大小size字节

				DeleteThread[] threadArray = new DeleteThread[threads];
				long totalRuntime = 0;

				long begin = System.currentTimeMillis();
				for (int i = 0; i < threads; i++) {
					WorkerStat stat = new WorkerStat();
					stat.runs = runs;
					threadArray[i] = new DeleteThread(stat, i);
					threadArray[i].start();
				}
				for (int i = 0; i < threads; i++) {
					threadArray[i].join();
				}

				totalRuntime = System.currentTimeMillis() - begin;

				WorkerStat totalStat = new WorkerStat();
				totalStat.runs = runs;
				totalStat.threads = threads;
				for (int i = 0; i < threads; i++) {
					totalStat.setterTime = totalStat.setterTime
							+ threadArray[i].getStat().setterTime;
					totalStat.getterTime = totalStat.getterTime
							+ threadArray[i].getStat().getterTime;
					totalStat.deleteTime = totalStat.deleteTime
							+ threadArray[i].getStat().deleteTime;
					totalStat.createTime = totalStat.createTime
							+ threadArray[i].getStat().createTime;
				}
				JSONObject result = (JSONObject) JSON.toJSON(totalStat);

				result.put("totalRunTime", totalRuntime);
				result.put("tps", runs * threads / totalRuntime * 1.0);
				result.put("time", new Date());
				System.out.println(result);
		
	}

	private void createNode() throws InterruptedException {
		CreateThread[] threadArray = new CreateThread[threads];
		long begin = System.currentTimeMillis();
		for (int i = 0; i < threads; i++) {
			WorkerStat stat = new WorkerStat();
			stat.runs = runs;
			threadArray[i] = new CreateThread(stat, i);
			threadArray[i].start();
		}
		long totalRuntime = System.currentTimeMillis() - begin;
		// 实现同步。 等待所有线程跑完。
		for (int i = 0; i < threads; i++) {
			threadArray[i].join();
		}
		totalRuntime = System.currentTimeMillis() - begin;
		
		WorkerStat totalStat = new WorkerStat();
		totalStat.runs = runs;
		totalStat.threads = threads;
		for (int i = 0; i < threads; i++) {
			totalStat.setterTime +=	threadArray[i].getStat().setterTime;
			totalStat.getterTime += threadArray[i].getStat().getterTime;
			totalStat.deleteTime += threadArray[i].getStat().deleteTime;
			totalStat.createTime += threadArray[i].getStat().createTime;
		}
		JSONObject result = (JSONObject) JSON.toJSON(totalStat);
		result.put("totalRunTime", totalRuntime);
		result.put("totalRuns", runs * threads);
		result.put("tps", runs * threads * 1.0 / totalRuntime);
		result.put("time", new Date().toString());
		System.out.println(result);
	}

	/**
	 * 连接zookeeper server
	 */
	public void connect() throws Exception {
		zk = new ZooKeeper(hosts, SESSION_TIMEOUT, new ConnWatcher());
		// 等待连接完成
		connectedSignal.await();
	}
	
	

	/**
	 * 以下为各个参数的详细说明: path. znode的路径. data. 与znode关联的数据. acl. 指定权限信息, 如果不想指定权限,
	 * 可以传入Ids.OPEN_ACL_UNSAFE. 指定znode类型. CreateMode是一个枚举类, 从中选择一个成员传入即可.
	 */

	/**
	 * 创建持久化节点
	 */
	private static void create(String Path, byte[] data) throws Exception {
		zk.create(Path, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
		// System.out.println("创建节点:"+Path);
		// System.out.println("=================");
	}

	/**
	 * 
	 * 获取节点信息
	 * 
	 * @author kiven
	 * @createDate 2013-01-16 15:17:22
	 * @param path
	 * @throws KeeperException
	 * @throws InterruptedException
	 */
	public void getChild(String path) throws KeeperException,
			InterruptedException {
		try {
			List<String> list = zk.getChildren(path, false);
			if (list.isEmpty()) {
				System.out.println(path + "中没有节点");
			} else {
				System.out.println(path + "中存在节点");
				for (String child : list) {
					System.out.println("节点为：" + child);
				}
			}
		} catch (KeeperException.NoNodeException e) {
			e.printStackTrace();
		}
	}

	/**
	 * 设置节点数据
	 * 
	 * @throws Exception
	 */
	public void setData(String path, String data) throws Exception {
		zk.setData(path, data.getBytes(), -1);
//		System.out.println("set Data:" + "testSetData");
	}

	/**
	 * 读取节点数据
	 * 
	 * @throws Exception
	 */
	public void getData() throws Exception {
//		System.out.println("get Data:");
		zk.getData(nodePath, false, null);
	}

	/**
	 * 删除节点
	 * 
	 * @param path
	 * @throws Exception
	 */
	public static void delete(String path) throws Exception {
//		System.out.println("删除节点:" + path);
		// 如果版本号与znode的版本号不一致，将无法删除，是一种乐观加锁机制；如果将版本号设置为-1，不会去检测版本，直接删除；
		int maxCount = 1000;
		if(deleteCount > maxCount){
			System.out.println(" 到达 "+maxCount+" 次 结束锁。");
		}
		zk.delete(path, -1);
		deleteCount++;
	}

	/**
	 * 关闭连接
	 */
	public void close() {
		try {
			zk.close();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	
	/*******************************   内部类        ***************************/
	
	/**
	 * @author Administrator
	 */
	private static class CreateThread extends Thread {
		protected WorkerStat stat;

		public WorkerStat getStat() {
			return stat;
		}

		public void setStat(WorkerStat stat) {
			this.stat = stat;
		}

		int num;

		CreateThread(WorkerStat stat, int num) {
			this.stat = stat;
			this.num = num;
		}

		public void run() {
			long begin = System.currentTimeMillis();
//			System.out.println("create：" + nodePath + "/" + "" + num + "_");
//			System.out.println("stat.runs：" + stat.runs);
			for (int i = 0; i < stat.runs; i++) {
				// 读取节点数据
				try {
					create(nodePath + "/" + "" + num + "_" + i, null);
					// System.out.println( "create："+nodePath+"/"+""+num+"_"+i
					// );
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			long end = System.currentTimeMillis();
			stat.createTime = end - begin;
//			 System.out.println( stat.createTime );
		}
	}
	
	/**
	 * @author Kiven 内部Watcher类
	 */
	public class ConnWatcher implements Watcher {
		public void process(WatchedEvent event) {
			// 连接建立, 回调process接口时, 其event.getState()为KeeperState.SyncConnected
			if (event.getState() == KeeperState.SyncConnected) {
				// 放开闸门, wait在connect方法上的线程将被唤醒
				// 完成工作 数量-1
				connectedSignal.countDown();
				watcherCount++;
			}
		}
	}
	
	/**
	 * @author Kiven 内部Watcher类
	 */
	public class GetWatcher implements Watcher {
		public void process(WatchedEvent event) {
			// 连接建立, 回调process接口时, 其event.getState()为KeeperState.SyncConnected
			if (event.getState() == KeeperState.SyncConnected) {
				watcherCountAdd();
//				System.out.println("get"+watcherCount+"次");
				
			}
//			产生回调
//			System.out.println(" watcher 总次数  = " + watcherCount);
//				try {
//					tLock();
//				} catch (IOException e) {
//					e.printStackTrace();
//				} catch (KeeperException e) {
//					e.printStackTrace();
//				} catch (InterruptedException e) {
//					e.printStackTrace();
//				}
		}
	}
	
	/**
	 * @author Kiven 内部Watcher类
	 */
	public class SetWatcher implements Watcher {
		public void process(WatchedEvent event) {
			// 连接建立, 回调process接口时, 其event.getState()为KeeperState.SyncConnected
			if (event.getState() == KeeperState.SyncConnected) {
				watcherCountAdd();
				System.out.println("set"+watcherCount+"次");
			}
		}
	}
	/**
	 * @author Kiven 内部Watcher类
	 */
	public class DeleteWatcher implements Watcher {
		public void process(WatchedEvent event) {
			// 连接建立, 回调process接口时, 其event.getState()为KeeperState.SyncConnected
				// 完成工作 数量-1
			if (event.getState() == KeeperState.SyncConnected) {
				watcherCountAdd();
				System.out.println("delete"+watcherCount+"次");
			}
		}
	}
	private static synchronized void watcherCountAdd(){
		watcherCount++;
//		System.out.println(watcherCount);
	}
	
	
	
	/**
	 * 删除线程
	 * @author Administrator
	 */
	private static class DeleteThread extends Thread {
		protected WorkerStat stat;

		public WorkerStat getStat() {
			return stat;
		}

		public void setStat(WorkerStat stat) {
			this.stat = stat;
		}

		int num;

		DeleteThread(WorkerStat stat, int num) {
			this.stat = stat;
			this.num = num;
		}

		public void run() {
			long begin = System.currentTimeMillis();
//			System.out.println(" delete:" + nodePath + "/" + "" + num + "_");
			for (int i = stat.start; i < stat.start + stat.runs; i++) {
				// 写入节点数据
				try {
					delete(nodePath + "/" + "" + num + "_" + i);
//					System.out.println(" delete:" + nodePath + "/" + "" + num
//							+ "_" + i);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			long end = System.currentTimeMillis();
			stat.deleteTime = end - begin;
		}
	}
	
	private static class SetThread extends Thread {
	    private WorkerStat stat;
	    CountDownLatch countDownLatch;
	    int  num;
	    public WorkerStat getStat() {
			return stat;
		}

		public  SetThread(WorkerStat stat,int  num) {
			this.countDownLatch=countDownLatch;
			this.stat = stat;
			this.num=num;
		}

		SetThread(WorkerStat stat) {
	        this.stat = stat;
	    }
	 
	    public void run() {
	        long begin = System.currentTimeMillis(); 
	        for (int i =0; i <runs; i++) {
	            //写入节点数据
	            try {
	            	//System.out.println("set:"+nodePath+"/"+""+num+"_"+i);
	            zk.setData(nodePath+"/"+""+num+"_"+i, testdata, -1);
	            } catch (Exception e) {
	            e.printStackTrace();
	            }
	        }
	        long end = System.currentTimeMillis();
	        stat.setterTime = end - begin;
	       
	    }
	}
	
	private static class GetThread extends Thread {
		private WorkerStat stat;
		CountDownLatch countDownLatch;
		int num;

		public WorkerStat getStat() {
			return stat;
		}

		public GetThread(WorkerStat stat, int num) {
			this.countDownLatch = countDownLatch;
			this.stat = stat;
			this.num = num;
		}

		GetThread(WorkerStat stat) {
			this.stat = stat;
		}

		public void run() {
			long begin = System.currentTimeMillis();
			for (int i = 0; i < runs; i++) {
				// 读取节点数据
				try {
					// System.out.println("set:"+nodePath+"/"+""+num+"_"+i);

					zk.getData(nodePath + "/" + "" + num + "_" + i, false, null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			long end = System.currentTimeMillis();
			stat.getterTime = end - begin;

		}
	}
	 
}
